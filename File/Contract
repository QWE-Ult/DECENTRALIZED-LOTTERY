// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract Lottery is ReentrancyGuard {
    address private manager; // Manager address
    address payable[] public players;
    address payable public Winner;
    uint public minimumval;
    uint public lotteryEndTime;
    uint public roundDuration; // changed: new variable for adjustable round duration
    bool public isPaused; // changed: allows pausing/resuming the lottery

    // changed: gas-efficient custom errors
    error NotManager();
    error LotteryOngoing();
    error LotteryNotEnded();
    error NotEnoughPlayers();
    error LotteryPaused();
    error InsufficientValue();

    event Participated(address indexed player, uint amount);
    event WinnerDeclared(address indexed winner, uint amount);
    event LotteryEnded(uint prizeAmount, address indexed winner);
    event LotteryPause();
    event LotteryResumed();

    constructor(uint _minimumval, uint _durationInMinutes) {
        manager = msg.sender;
        minimumval = _minimumval;
        roundDuration = _durationInMinutes * 1 minutes; // changed
        lotteryEndTime = block.timestamp + roundDuration;
        isPaused = false; // changed
    }

    modifier onlyManager() {
        if (msg.sender != manager) revert NotManager(); // changed
        _;
    }

    modifier hasEnded() {
        if (block.timestamp < lotteryEndTime) revert LotteryNotEnded(); // changed
        _;
    }

    modifier notPaused() {
        if (isPaused) revert LotteryPaused(); // changed
        _;
    }

    function pauseLottery() external onlyManager { // changed: new function
        isPaused = true;
        emit LotteryPause();
    }

    function resumeLottery() external onlyManager { // changed: new function
        isPaused = false;
        emit LotteryResumed();
    }

    function participate() external payable notPaused { // changed: added notPaused modifier
        if (msg.value < minimumval) revert InsufficientValue(); // changed
        if (block.timestamp >= lotteryEndTime) revert LotteryOngoing(); // changed

        players.push(payable(msg.sender));
        emit Participated(msg.sender, msg.value);
    }

    function checkBal() external view returns (uint) {
        return address(this).balance;
    }

    function viewPlayers() external view returns (address payable[] memory) { // changed: view participant list
        return players;
    }

    function random() internal view returns (uint) { // changed: made internal
        return uint(
            keccak256(
                abi.encodePacked(block.prevrandao, block.timestamp, players.length)
            )
        );
    }

    function win() external onlyManager hasEnded nonReentrant {
        if (players.length <= 3) revert NotEnoughPlayers(); // changed

        uint index = random() % players.length;
        Winner = players[index];
        uint prizeAmount = address(this).balance;

        Winner.transfer(prizeAmount);
        emit WinnerDeclared(Winner, prizeAmount);
        emit LotteryEnded(prizeAmount, Winner);

        delete players;
        lotteryEndTime = block.timestamp + roundDuration; // changed
    }
}
